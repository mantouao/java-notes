### 什么是代理模式

代理模式的主要思想就是让业务类只完成核心业务，附加的业务都交给代理人干，你可以这么理解，你是个明星歌手，你的任务只是唱歌，其他卖演唱会的票，接广告等都交给经纪人干，歌手就是业务类(目标类，被代理类)，经纪人就是代理类。



代理类又分为静态和动态代理

### 静态代理

静态代理也就是我们最开始的代理方法，全都由自己完成。具体实现是这样的，我们肯定先有两个类，一个代理类和一个被代理类，被代理类完成核心任务，代理类完成附加任务。代理完成附加业务后要通知被代理类去完成核心任务，其次代理类和被代理类要实现相同的接口，为什么呢？1.代理类和被代理类可以统一类型来保证安全 2.未来的拓展方便 3. 也是我认为最重要的，客户端是不知道我用的是代理类还是目标类，为什么这样说，在我们依赖注入的时候，通常都是客户端通过某个方法去要需要的目标类对象，因为我们让代理类和被代理实现同一个接口，所以我们可以返回一个代理对象，来完成我们的目的。

示例：

被代理类（核心业务类）

```java
public class CoreTask implements Iwork{
    @Override
    public void work() {
        System.out.println("我是明星，我要唱歌");
    }
}
```

代理类

```java
public class Proxy implements Iwork{
    Iwork core_task;
    public Proxy(Iwork core_task){
        this.core_task = core_task;
    }
    @Override
    public void work() {
        System.out.println("我是经纪人，我先卖票");
        core_task.work();
        System.out.println("唱完了，我去数钱");
    }
}
```

统一的接口

```java
public interface Iwork {
    void work();
}

```



客户端去访问核心类（观众去买票）

```java
public class Test {
    public static void main(String[] args) {
        Iwork core_task = getCoreTask();
        core_task.work();
    }

    private static Iwork getCoreTask() {
        return new Proxy(new CoreTask());
    }
}
```

```shell
我是经纪人，我先卖票
我是明星，我要唱歌
唱完了，我去数钱
```



### 动态代理

静态代理有个问题，太麻烦了，有一个核心业务我就写一个代理类，这不行，想办法偷懒。

所以怎么办，想出来了动态代理，动态代理是怎么样的？和静态代理大同小异，核心业务类（被代理类）不变，我如果不想一个业务类一个代理怎么办，我先提出一个统一的代理策略，我创建代理对象的时候，自动用这个代理策略来生产代理类，就不用手写了。

代码中是怎么体现的：

核心业务不变：

```java
public class CoreTask implements Iwork {

    @Override
    public void work() {
        System.out.println("我是明星，我要唱歌");
    }
}
```

继承接口不变：

```java
public interface Iwork {
    void work();
}
```

接下来我们就要自己写代理策略了，动态代理写这个策略，我们需要实现InvocationHandler接口并实现invoke方法。

```java
public class MyProxy implements InvocationHandler {
    Iwork core_task;
    public MyProxy(Iwork core_task){
        this.core_task = core_task;
    }
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //调用方法之前，我们可以添加自己的操作
        System.out.println("我是经纪人，我先卖票");

        //调用被代理的方法
        Object result = method.invoke(core_task, args);
        //调用方法之后，我们同样可以添加自己的操作
        System.out.println("唱完了，我去数钱");
        return result;
    }
}
```

这里的method.invoke其实就是用反射实现的，通过反射去找到方法

到这里，我们的准备就完成了，接下来就可以创建代理对象来自动生成代理类了

生成代理对象要用Proxy类的静态方法newProxyInstance

```java
public static void main(String[] args) {
        Iwork coreTask = new CoreTask();
        Iwork proxyInstance = (Iwork) Proxy.newProxyInstance(coreTask.getClass().getClassLoader()
                , coreTask.getClass().getInterfaces()
                , new MyProxy(coreTask));
        proxyInstance.work();
    }
```

这里的newProxyInstance有三个参数,被代理的类加载器,被代理类的接口列表,代理处理策略

（InvocationHandler）

结果：

```shell
我是经纪人，我先卖票
我是明星，我要唱歌
唱完了，我去数钱

```



这个是jdk的动态代理，还有一种是cglib的，简单的了解下就是cglib是不用实现接口的，jdk是需要的，效率上好像是比jdk的动态代理好一点，就是不用接口的用cglib，有接口用jdk的。
