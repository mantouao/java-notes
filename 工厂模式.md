### 什么是工厂模式

**工厂模式**（Factory Pattern）是一种创建型设计模式，它提供了一种创建对象的方式，隐藏了具体的实现细节。

### 工厂模式的优点

1. **解耦**：客户端代码与具体产品类解耦，只通过工厂来创建对象。
2. **可扩展性**：增加新产品时，只需增加相应的工厂类，无需修改现有代码。
3. **统一管理**：将对象创建的逻辑集中在工厂类中，便于管理和维护。

### 工厂模式设计思路

首先工厂模式分为 **工厂方法模式** 和 **抽象工厂模式**

#### 工厂方法模式

工厂方法模式有三种实现方式，看着多，其实都大同小异

现在有IA_B这个产品大类

```java
public interface IA_B {
    public void print();
}
```

大类中有具体A和B两个产品

```java
public class A implements IA_B{
    @Override
    public void print() {
        System.out.println("AAAA");
    }
}
```

```java
public class B implements IA_B{
    @Override
    public void print() {
        System.out.println("BBBB");
    }
}
```

我现在用工厂统一生产IA_B的产品

```java
public class PuTongFactory {
    //第一种：普通工厂方法
    public IA_B Factory1(String type){
        if (type.equals("A")){
            return new A();
        }else if (type.equals("B")) {
            return new B();
        }else {
            System.out.println("输入正确的类型");
            return null;
        }
    }
    //第二种：多个工厂方法
    public IA_B Factory2_A(){
        return new A();
    }
    public IA_B Factory2_B(){
        return new B();
    }
    //第三种：静态工厂方法
    public static  IA_B Factory3_A(){
        return new A();
    }
    public static  IA_B Factory3_B(){
        return new B();
    }
}
```

可以看到其实普通工厂方法一般冗杂到一个方法中，根据客户传递的参数来决定创建什么产品。普通方法有一个小问题，就是如果客户传错了参数就无法生产产品。

就有了多个工厂方法，这个客户要用工厂对象去调用具体的方法来生产产品，这下好了，客户不可能有传错参数了，我都告诉你能创建什么产品，你不能在传错吧！

静态工厂就是省去了new工厂类的功夫，直接用类名.方法就能创建对象了。



**注意：问题来了，有没有发现工厂方法模式这三种方式都有一个问题。违反了开闭原则，我们一般规定：对程序的拓展是开放的，对程序的修改是封闭的。我们如果想在添加一个产品C就要在工厂类中添加个方法，这不是修改代码了吗？所有怎么办。我们把工厂类拆分开，每个产品都有自己的工厂 互不影响，之前是所有产品由一个工厂干，耦合太高了，就此抽象工厂来了！！！**



#### 抽象工厂模式

A，B产品和IA_B大类不变，我们生产IA_B的工厂模式改一改

```java
public interface I_chou_xiang_factory {
    public IA_B Produce();
}

```

```java
public class Imp_factory_A implements I_chou_xiang_factory{
    @Override
    public IA_B Produce() {
        return new A();
    }
}
```

```java
public class Imp_factory_B implements I_chou_xiang_factory{
    @Override
    public IA_B Produce() {
        return new B();
    }
}

```



注意到了吗？原来我们是耦合在一个工厂类，现在我们分别有生产A的工厂和B的工厂，他们都实现了抽象工厂，可以这样理解，这个抽象工厂的接口就是一个大的工厂，Imp_factory_A和Imp_factory_B是他的一个小部门，专门来生产A和生产B的，如果这个时候开发出C产品我只要在这个大工厂中创建一个专门生产C的部门就好，和以前彻底不一样了，以前我们工厂的工人，又要生产A，又要生产B，来了C就要让这些人再去生产C，现在，我把工厂的工人分成对应的部门，部门A就专心生产A，部门B就专心生产B,大大降低了工人的耦合度。




